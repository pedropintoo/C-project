

Disk :: Model {

    size : Number = 1;
    action on size {
        wood.length = (50 + 25 * size, 15);
    }

    wood: Rectangle with {
        length = (75,15);
        fill = "brown";
    }
}

Base :: Model {
    rec : Rectangle with {
        length = (200,20);
        fill = "brown";
    }

    Text with {
        text = "Base";
    }

    stick: Rectangle at (0,120) with {
        length = (10,100);
        fill = "brown";
    }
}

Tower :: Model {
    base : Base;

    numberOfDisks : Number = 0;
    
    disks : Array = [None]; # Array<Disk>
    action on disks {
        for d in 0..numberOfDisks do {
            move disks[d] to (base.origin[0], (d+1)*30 - 45);
        }
    }

    active : Boolean = False;
    action on active {
        if (active) do
            disks[numberOfDisks-1].wood.fill = "green";
        else do
            disks[numberOfDisks-1].wood.fill = "brown";
    }
}

Game :: Model {

    diskL : Disk; diskL.size = 3;
    diskM : Disk; diskM.size = 2;
    diskS : Disk; diskS.size = 1;

    tower1 : Tower at (0,-50);
    tower2 : Tower at (500, -50);
    tower3 : Tower at (1000, -50);
}

view1: View with {
    width = 500;
    height = 500;
    title = "Tower 1";
    background = "wheat";
}

view2: View with {
    Ox = 500;
    width = 500;
    height = 500;
    title = "Tower 2";
    background = "wheat";
}

view3: View with {
    Ox = 1000;
    width = 500;
    height = 500;
    title = "Tower 3";
    background = "wheat";
}

game : Game;

game.tower1.numberOfDisks = 3;
game.tower1.disks = [game.diskL, game.diskM, game.diskS];

refresh view1; refresh view1;
refresh view2;
refresh view3;

p : Point = wait mouse click; 
print p;

refresh view1;
refresh view2;
refresh view3;

while True do {
    p : Point = wait mouse click;
    
    print p;
    if p[0] < 250 do {
        print "Tower 1"; # Ativa a torre1 -> ultimo da lista fica selecionado
                         # Tem se de ficar á espera do segundo click
                         # No segundo click sabe-se a torre destino
                         # E poe se o disco na array da torre destino
                         # Funciona como se fosse stack, 
                         # Põe-se no fim da array e tira-se do fim da array
                         # Só é válido colocar no fim da array discos menores que o último colocado
                         # Dentro das torres está a lógica de, cada vez que a array muda, colocar os mans bem
    
    }
    else do 
        if p[0] < 750 do 
            print "Tower 2";
        else do {
            print "Tower 3";
        }

   refresh view1, view2, view3;
}






