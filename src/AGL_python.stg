module(stat) ::= <<
from tkinter import *
import time, os, sys

#################################################################
## Auxiliar
#################################################################
REFRESH_RATE = 0.1
last_refresh = time.time()
canvas_global = None
mouseX = None
mouseY = None
#################################################################
def coord(point):
    x = point[0]
    y = point[1]
    return (width/2-Ox+x, height/2+Oy-y)

def length(origin, x, y):
    return (origin[0]+x, origin[1]-y)

def rectangle(origin, length):
    p0 = (origin[0]-length[0]/2,origin[1]-length[1]/2)
    p1 = (origin[0]+length[0]/2,origin[1]-length[1]/2)
    p2 = (origin[0]+length[0]/2,origin[1]+length[1]/2)
    p3 = (origin[0]-length[0]/2,origin[1]+length[1]/2)
    return p0,p1,p2,p3,p0

def ellipse(origin, length):
    return (origin[0]-length[0]/2,origin[1]-length[1]/2),(origin[0]+length[0]/2,origin[1]+length[1]/2)

def onClick(event):
    global mouseX, mouseY
    mouseX, mouseY = event.x, event.y

def getMouse():
    global mouseX, mouseY
    top.update()
    mouseX = None; mouseY = None
    while mouseX == None:
        time.sleep(.1)
        top.update()

def waitClick():
    top.bind("\<Button-1\>", onClick)
    getMouse()
    return mouseX-width/2+Ox, height/2+Oy-mouseY
#################################################################


if __name__ == "__main__":
    root = Tk()
    root.withdraw()

    # default View values
    top = Toplevel(root)
    Ox = 0
    Oy = 0
    width = 201
    height = 201
    top.title("No title") 
    background = "black"

    <stats(stat)>
>>

stats(stat) ::= <<
<if(stat)><stat; separator="\n"><endif>
>>

properties(field) ::= <<
<if(field)><field; separator=","><endif>
>>

waitMouseClick(var) ::= <<
<var> = waitClick()
>>

refresh(stat, view, delay) ::= <<
<if(delay)> 
<stats(stat)>
while (time.time() - last_refresh \<= <delay>):
    time.sleep(REFRESH_RATE)   

<endif>
last_refresh = time.time()
top.update() # TODO: Update only the view!
>>

print(stat, output) ::= <<
<stats(stat)>
print(<output>)
>>

for(var, range, stat, instruction) ::= <<
<stats(stat)>
for <var> in <range>:
    <stats(instruction)>
>>

range(start, end, step) ::= "range(<start>, <end>, <step>)"

assign(stat,var,value,attribute) ::= <<
<stats(stat)>
<if(value)><var><if(attribute)>.<attribute><endif> = <value><endif>
>>

init(value) ::= "<if(value)> = <value><endif>"
decl(var, value) ::= "<var><init(value)>"

binaryExpression(stat,var,e1,op,e2) ::= <<
<stats(stat)>
<decl(var,[e1," ",op," ",e2])>
>>

unaryExpression(stat,var,op,e1) ::= <<
<stats(stat)>
<decl(var,[op," ",e1])>
>>



canvas(stat, var, view_properties) ::= <<
<stats(stat)>

<view_properties>

<var> = Canvas(top, height=height, width=width, background=background)
<var>.pack()
canvas_global = <var>
>>

view_properties(Ox, Oy, height, width, title, background) ::= <<
<if(Ox)>Ox=<Ox><endif>
<if(Oy)>Oy=<Oy><endif>
<if(height)>height=<height><endif>
<if(width)>width=<width><endif>
<if(title)>top.title(<title>)<endif>
<if(background)>background=<background><endif>
>>

line(stat, var, origin, length, fill) ::= <<
<stats(stat)>

origin = coord(<origin>)
length = <length>
canvas_global.create_line(rectangle(origin, length), fill=<fill>)
>>
